<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm · JuliaOpenGL</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaOpenGL</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../files/JuliaOpenGL/">JuliaOpenGL.jl</a></li><li><a class="toctext" href="../../files/build/">build.jl</a></li><li><a class="toctext" href="../../files/camera/">camera.jl</a></li><li><a class="toctext" href="../../files/chunk/">chunk.jl</a></li><li><a class="toctext" href="../../files/compileAndLink/">compileAndLink.jl</a></li><li><a class="toctext" href="../../files/cubeData/">cubeData.jl</a></li><li><a class="toctext" href="../../files/frustum/">frutsum.jl</a></li><li><a class="toctext" href="../../files/lib_math/">lib_math.jl</a></li><li><a class="toctext" href="../../files/lib_opengl/">lib_opengl.jl</a></li><li><a class="toctext" href="../../files/lib_time/">lib_time.jl</a></li><li><a class="toctext" href="../../files/lib_window/">lib_window.jl</a></li><li><a class="toctext" href="../../files/libs/">libs.jl</a></li><li><a class="toctext" href="../../files/matrix/">matrix.jl</a></li><li><a class="toctext" href="../../files/mesh/">mesh.jl</a></li><li><a class="toctext" href="../../files/shader/">shader.jl</a></li><li><a class="toctext" href="../../files/test/">test.jl</a></li><li><a class="toctext" href="../../files/texture/">texture.jl</a></li><li><a class="toctext" href="../../files/vector/">vector.jl</a></li><li><a class="toctext" href="../../">JuliaOpenGL</a></li><li class="current"><a class="toctext" href>Algorithm</a><ul class="internal"><li><a class="toctext" href="#OpenGL-1">OpenGL</a></li><li><a class="toctext" href="#Frustum-Culling-1">Frustum Culling</a></li><li><a class="toctext" href="#Outside-Only-1">Outside Only</a></li><li><a class="toctext" href="#All-together-1">All together</a></li><li><a class="toctext" href="#Next-step-1">Next step</a></li><li><a class="toctext" href="#Why-not-use?-1">Why not use?</a></li></ul></li><li><a class="toctext" href="../optimization/">Optimization</a></li><li><a class="toctext" href="../references/">References</a></li><li><a class="toctext" href="../start/">Start</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Algorithm</a></li></ul><a class="edit-page" href="https://github.com/Gilga/JuliaOpenGL/blob/master/doc/src/manual/algorithm.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Algorithm</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="algorithm-1" href="#algorithm-1">Algorithm</a></h1><p>For this project i use an advanced OpenGL technique and two algorithm to render up to 128³ blocks with 100 or more FPS.</p><ul><li><p><a href="#OpenGL-1">OpenGL</a></p></li><li><p><a href="#Frustum-Culling-1">Frustum Culling</a></p></li><li><p><a href="#Outside-Only-1">Outside Only</a></p></li><li><p><a href="#All-together-1">All together</a></p></li><li><p><a href="#Next-step-1">Next step</a></p></li><li><p><a href="#Why-not-use?-1">Why not use?</a></p></li></ul><h2><a class="nav-anchor" id="OpenGL-1" href="#OpenGL-1">OpenGL</a></h2><ul><li><p>glDrawElementsInstanced and glDrawArraysInstanced to render many objects at once</p></li><li><p>GPU Geometry shader to adjust amount of vertices given by input. No need to create vertices on CPU side. </p></li></ul><p>Geometry shader example:</p><pre><code class="language-none">void createSide(Vertex v, int side) {
  for(int i=0;i&lt;4;++i) {
    (...)
    gl_Position = iMVP * v.world_pos;
    EmitVertex();
  }
  EndPrimitive();
}

void main() {
  (...)
  if((sides &amp; 0x1) &gt; 0) createSide(v, 4);  // LEFT
  if((sides &amp; 0x2) &gt; 0) createSide(v, 5);  // RIGHT
  if((sides &amp; 0x4) &gt; 0) createSide(v, 0);  // TOP
  if((sides &amp; 0x8) &gt; 0) createSide(v, 1);  // BOTTOM
  if((sides &amp; 0x10) &gt; 0) createSide(v, 2);  // FRONT
  if((sides &amp; 0x20) &gt; 0) createSide(v, 3);  // BACK
  (...)
}</code></pre><h2><a class="nav-anchor" id="Frustum-Culling-1" href="#Frustum-Culling-1">Frustum Culling</a></h2><p>Frustum culling is 3d geometric object (a cone with top and bottom sliced off). In code frustum has six planes (top,bottom,right,left,near,far) in total where each plane measure the distance between itself and a given object. </p><p>For visual demonstration look <a href="https://youtu.be/E6r9IzakO0U">Frustum Culling Video</a> by AlwaysGeeky.</p><p><em>Code:</em></p><pre><code class="language-none">type Plane
 position  :: Vector
 normal    :: Vector
 distance  :: Value
end</code></pre><pre><code class="language-none">type Frustum
  planes :: Array
  
  nearDistance  :: Value
  farDistance   :: Value
  nearWidth     :: Value
  nearHeight    :: Value
  farWidth      :: Value
  farHeight     :: Value
  ratio         :: Value
  angle         :: Value
  tang          :: Value
  
  nearTopLeft     :: Vector
  nearTopRight    :: Vector
  nearBottomLeft  :: Vector
  nearBottomRight :: Vector
  farTopLeft      :: Vector
  farTopRight     :: Vector
  farBottomLeft   :: Vector
  farBottomRight  :: Vector
end</code></pre><p>Set Camera is called in main script and sets the view for the frustum <a href="manual/@ref"><code>App.SetCamera(this::App.Frustum, pos::App.Vec3f, target::App.Vec3f, up::App.Vec3f)</code></a></p><p>Set Frustum is almost similiar to set camera execpt its sets ratio, angle, far and near values <a href="manual/@ref"><code>App.SetFrustum(this::App.Frustum, angle::Float32, ratio::Float32, nearD::Float32, farD::Float32)</code></a></p><p>GetPointDistance gets the distance between current plane and a point <a href="manual/@ref"><code>App.GetPointDistance(this::App.Plane3D, lPoint::App.Vec3f)</code></a></p><p>checkSphere is a batter option than checkCube because its faster <a href="manual/@ref"><code>App.checkSphere(this::App.Frustum, pos::App.Vec3f, radius::Number)</code></a></p><p>checkInFrustum is called in when blocks are created / updated <a href="manual/@ref"><code>App.checkInFrustum(this::App.Chunk, fstm::App.Frustum)</code></a></p><h2><a class="nav-anchor" id="Outside-Only-1" href="#Outside-Only-1">Outside Only</a></h2><p>Is a simple algorithm to filter objects which are surrounded by other objects and are not visible from the outside. It hides not only the objects itself but its non-visible sides too. Those objects are cubes so we have only six sides to check for visibility.</p><p>The algorithm <a href="manual/@ref"><code>App.hideUnseen(this::App.Chunk)</code></a></p><h2><a class="nav-anchor" id="All-together-1" href="#All-together-1">All together</a></h2><p>Combining OpenGL technique and those two algorithm gives high quality results.</p><p>This gets us a filtered list of objects where those algorithms were applied to <a href="manual/@ref"><code>App.getFilteredChilds(this::App.Chunk)</code></a></p><h2><a class="nav-anchor" id="Next-step-1" href="#Next-step-1">Next step</a></h2><p>Next step is to filter objects which are not seen due to interference of other objects (blocking the view). An approach could be using a raytracer but maybe there is an even better solution to that or it has yet to been found. Since we only have cubes we can avoid complicated stuff most of the time.</p><h2><a class="nav-anchor" id="Why-not-use?-1" href="#Why-not-use?-1">Why not use?</a></h2><p><em>Why not use glDrawElementsInstanced + geometry shader instead of glDrawArraysInstanced + geometry shader?</em> glDrawElementsInstanced is only useful for groups but we use points here for each object (cube), so we will have to think how we want to group our objects first. Currently glDrawArraysInstanced is the way to go.</p><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">JuliaOpenGL</span></a><a class="next" href="../optimization/"><span class="direction">Next</span><span class="title">Optimization</span></a></footer></article></body></html>
